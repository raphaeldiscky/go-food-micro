// Package tracing provides a module for the tracing.
package tracing

// https://opentelemetry.io/docs/reference/specification/
// https://opentelemetry.io/docs/instrumentation/go/getting-started/
// https://opentelemetry.io/docs/instrumentation/go/manual/
// https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/
// https://uptrace.dev/opentelemetry/go-tracing.html
// https://lightstep.com/blog/opentelemetry-go-all-you-need-to-know
// https://trstringer.com/otel-part2-instrumentation/
// https://trstringer.com/otel-part5-propagation/
// https://github.com/tedsuo/otel-go-basics/blob/main/server.go
// https://github.com/riferrei/otel-with-golang/blob/main/main.go

import (
	"context"
	"os"
	"time"

	"emperror.dev/errors"
	"github.com/samber/lo"
	"go.opentelemetry.io/contrib/propagators/ot"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
	"go.opentelemetry.io/otel/exporters/zipkin"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"

	tracesdk "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"

	"github.com/raphaeldiscky/go-food-micro/internal/pkg/config/environment"
)

// TracingOpenTelemetry is a tracing open telemetry.
type TracingOpenTelemetry struct {
	config      *TracingOptions
	environment environment.Environment
	appTracer   AppTracer
	provider    *tracesdk.TracerProvider
}

// NewOtelTracing creates a new otel tracing.
// Create one tracer per package
// NOTE: You only need a tracer if you are creating your own spans.
func NewOtelTracing(
	config *TracingOptions,
	environment environment.Environment,
) (*TracingOpenTelemetry, error) {
	otelTracing := &TracingOpenTelemetry{
		config:      config,
		environment: environment,
	}

	resource, err := otelTracing.newResource()
	if err != nil {
		return nil, errors.WrapIf(err, "failed to create resource")
	}

	appTracer, err := otelTracing.initTracer(resource)
	if err != nil {
		return nil, err
	}

	otelTracing.appTracer = appTracer

	return otelTracing, nil
}

// Shutdown shuts down the tracing.
func (o *TracingOpenTelemetry) Shutdown(ctx context.Context) error {
	return o.provider.Shutdown(ctx)
}

// newResource creates a new resource.
func (o *TracingOpenTelemetry) newResource() (*resource.Resource, error) {
	// https://github.com/uptrace/uptrace-go/blob/master/example/otlp-traces/main.go#L49C1-L56C5
	resource, err := resource.New(context.Background(),
		resource.WithTelemetrySDK(),
		resource.WithAttributes(
			semconv.ServiceName(o.config.ServiceName),
			semconv.ServiceVersion(o.config.Version),
			attribute.Int64("ID", o.config.ID),
			attribute.String("environment", o.environment.GetEnvironmentName()),
			semconv.TelemetrySDKLanguageGo,
		))

	return resource, err
}

// initTracer initializes the tracer.
func (o *TracingOpenTelemetry) initTracer(
	resource *resource.Resource,
) (AppTracer, error) {
	exporters, err := o.configExporters()
	if err != nil {
		return nil, err
	}

	var sampler tracesdk.Sampler
	if o.config.AlwaysOnSampler {
		sampler = tracesdk.AlwaysSample()
	} else {
		sampler = tracesdk.NeverSample()
	}

	batchExporters := lo.Map(
		exporters,
		func(item tracesdk.SpanExporter, _ int) tracesdk.TracerProviderOption {
			return tracesdk.WithBatcher(item)
		},
	)

	// https://opentelemetry.io/docs/instrumentation/go/exporting_data/#resources
	// Resources are a special type of attribute that apply to all spans generated by a process
	opts := append(
		batchExporters,
		tracesdk.WithResource(resource),
		tracesdk.WithSampler(sampler),
	)

	provider := tracesdk.NewTracerProvider(opts...)

	// Register our tracerProvider as the global so any imported
	// instrumentation in the future will default to using it.
	otel.SetTracerProvider(provider)
	o.provider = provider

	// https://github.com/open-telemetry/opentelemetry-go-contrib/blob/main/propagators/ot/ot_propagator.go
	// https://github.com/open-telemetry/opentelemetry-go/blob/main/propagation/trace_context.go
	// https://github.com/open-telemetry/opentelemetry-go/blob/main/propagation/baggage.go/
	// https://trstringer.com/otel-part5-propagation/
	otel.SetTextMapPropagator(
		propagation.NewCompositeTextMapPropagator(
			ot.OT{}, // should be placed before `TraceContext` for preventing conflict
			propagation.Baggage{},
			propagation.TraceContext{},
		),
	)

	// https://trstringer.com/otel-part2-instrumentation/
	// Finally, set the tracer that can be used for this package. global app tracer
	appTracer := NewAppTracer(o.config.InstrumentationName)

	return appTracer, nil
}

// configExporters configures the exporters.
func (o *TracingOpenTelemetry) configExporters() ([]tracesdk.SpanExporter, error) {
	ctx := context.Background()
	traceOpts := []otlptracegrpc.Option{
		otlptracegrpc.WithTimeout(5 * time.Second),
		otlptracegrpc.WithInsecure(),
	}

	if o.config.UseOTLP {
		return o.configureOTLPExporters(ctx, traceOpts)
	}

	return o.configureLegacyExporters(ctx, traceOpts)
}

// configureOTLPExporters configures the otlp exporters.
func (o *TracingOpenTelemetry) configureOTLPExporters(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
) ([]tracesdk.SpanExporter, error) {
	var exporters []tracesdk.SpanExporter
	for _, oltpProvider := range o.config.OTLPProviders {
		if !oltpProvider.Enabled {
			continue
		}
		opts := append(traceOpts,
			otlptracegrpc.WithEndpoint(oltpProvider.OTLPEndpoint),
			otlptracegrpc.WithHeaders(oltpProvider.OTLPHeaders))

		exporter, err := otlptracegrpc.New(ctx, opts...)
		if err != nil {
			return nil, errors.WrapIf(err, "failed to create otlptracegrpc exporter")
		}
		exporters = append(exporters, exporter)
	}

	return exporters, nil
}

// configureLegacyExporters configures the legacy exporters.
func (o *TracingOpenTelemetry) configureLegacyExporters(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
) ([]tracesdk.SpanExporter, error) {
	var exporters []tracesdk.SpanExporter

	if err := o.addJaegerExporter(ctx, traceOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addTempoExporter(ctx, traceOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addZipkinExporter(&exporters); err != nil {
		return nil, err
	}
	if err := o.addElasticApmExporter(ctx, traceOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addUptraceExporter(ctx, traceOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addSignozExporter(ctx, traceOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addStdoutExporter(&exporters); err != nil {
		return nil, err
	}

	return exporters, nil
}

// addJaegerExporter adds the jaeger exporter.
func (o *TracingOpenTelemetry) addJaegerExporter(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
	exporters *[]tracesdk.SpanExporter,
) error {
	if o.config.JaegerExporterOptions == nil {
		return nil
	}
	opts := append(traceOpts,
		otlptracegrpc.WithEndpoint(o.config.JaegerExporterOptions.OTLPEndpoint),
		otlptracegrpc.WithHeaders(o.config.JaegerExporterOptions.OTLPHeaders))

	exporter, err := otlptracegrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create oltptrace exporter for jaeger")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addTempoExporter adds the tempo exporter.
func (o *TracingOpenTelemetry) addTempoExporter(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
	exporters *[]tracesdk.SpanExporter,
) error {
	if o.config.TempoExporterOptions == nil {
		return nil
	}
	opts := append(traceOpts,
		otlptracegrpc.WithEndpoint(o.config.TempoExporterOptions.OTLPEndpoint),
		otlptracegrpc.WithHeaders(o.config.TempoExporterOptions.OTLPHeaders))

	exporter, err := otlptracegrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create oltptrace exporter for grafana-tempo")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addZipkinExporter adds the zipkin exporter.
func (o *TracingOpenTelemetry) addZipkinExporter(exporters *[]tracesdk.SpanExporter) error {
	if o.config.ZipkinExporterOptions == nil {
		return nil
	}
	exporter, err := zipkin.New(o.config.ZipkinExporterOptions.Url)
	if err != nil {
		return errors.WrapIf(err, "failed to create exporter for zipkin")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addElasticApmExporter adds the elastic apm exporter.
func (o *TracingOpenTelemetry) addElasticApmExporter(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
	exporters *[]tracesdk.SpanExporter,
) error {
	if o.config.ElasticApmExporterOptions == nil {
		return nil
	}
	opts := append(traceOpts,
		otlptracegrpc.WithEndpoint(o.config.ElasticApmExporterOptions.OTLPEndpoint),
		otlptracegrpc.WithHeaders(o.config.ElasticApmExporterOptions.OTLPHeaders))

	exporter, err := otlptracegrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create oltptrace exporter for elastic-apm")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addUptraceExporter adds the uptrace exporter.
func (o *TracingOpenTelemetry) addUptraceExporter(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
	exporters *[]tracesdk.SpanExporter,
) error {
	if o.config.UptraceExporterOptions == nil {
		return nil
	}
	opts := append(traceOpts,
		otlptracegrpc.WithEndpoint(o.config.UptraceExporterOptions.OTLPEndpoint),
		otlptracegrpc.WithHeaders(o.config.UptraceExporterOptions.OTLPHeaders))

	exporter, err := otlptracegrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create oltptrace exporter for uptrace")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addSignozExporter adds the signoz exporter.
func (o *TracingOpenTelemetry) addSignozExporter(
	ctx context.Context,
	traceOpts []otlptracegrpc.Option,
	exporters *[]tracesdk.SpanExporter,
) error {
	if o.config.SignozExporterOptions == nil {
		return nil
	}
	opts := append(traceOpts,
		otlptracegrpc.WithEndpoint(o.config.SignozExporterOptions.OTLPEndpoint),
		otlptracegrpc.WithHeaders(o.config.SignozExporterOptions.OTLPHeaders))

	exporter, err := otlptracegrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create oltptrace exporter for signoz")
	}
	*exporters = append(*exporters, exporter)

	return nil
}

// addStdoutExporter adds the stdout exporter.
func (o *TracingOpenTelemetry) addStdoutExporter(exporters *[]tracesdk.SpanExporter) error {
	if !o.config.UseStdout {
		return nil
	}
	exporter, err := stdouttrace.New(
		stdouttrace.WithWriter(os.Stdout),
		stdouttrace.WithPrettyPrint(),
	)
	if err != nil {
		return errors.WrapIf(err, "creating stdout exporter")
	}
	*exporters = append(*exporters, exporter)

	return nil
}
