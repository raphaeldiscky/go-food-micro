// Package metrics provides a module for the metrics.
package metrics

// https://github.com/riferrei/otel-with-golang/blob/main/main.go
// https://github.com/open-telemetry/opentelemetry-go/blob/main/example/prometheus/main.go
// https://opentelemetry.io/docs/instrumentation/go/manual/#metrics

import (
	"context"
	"time"

	"emperror.dev/errors"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/samber/lo"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/exporters/prometheus"
	"go.opentelemetry.io/otel/exporters/stdout/stdoutmetric"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"

	echo "github.com/labstack/echo/v4"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"

	"github.com/raphaeldiscky/go-food-micro/internal/pkg/config/environment"
	"github.com/raphaeldiscky/go-food-micro/internal/pkg/http/customecho/contracts"
	"github.com/raphaeldiscky/go-food-micro/internal/pkg/logger"
)

// OtelMetrics is a metrics.
type OtelMetrics struct {
	config      *MetricsOptions
	logger      logger.Logger
	appMetrics  AppMetrics
	environment environment.Environment
	provider    *metric.MeterProvider
}

// NewOtelMetrics adds otel metrics.
func NewOtelMetrics(
	config *MetricsOptions,
	logger logger.Logger,
	environment environment.Environment,
) (*OtelMetrics, error) {
	if config == nil {
		return nil, errors.New("metrics config can't be nil")
	}

	otelMetrics := &OtelMetrics{
		config:      config,
		logger:      logger,
		environment: environment,
	}

	resource, err := otelMetrics.newResource()
	if err != nil {
		return nil, errors.WrapIf(err, "failed to create resource")
	}

	appMetrics, err := otelMetrics.initMetrics(resource)
	if err != nil {
		return nil, err
	}

	otelMetrics.appMetrics = appMetrics

	return otelMetrics, nil
}

// Shutdown shuts down the metrics.
func (o *OtelMetrics) Shutdown(ctx context.Context) error {
	return o.provider.Shutdown(ctx)
}

// newResource creates a new resource.
func (o *OtelMetrics) newResource() (*resource.Resource, error) {
	// https://github.com/uptrace/uptrace-go/blob/master/example/otlp-traces/main.go#L49C1-L56C5
	resource, err := resource.New(
		context.Background(),
		resource.WithFromEnv(),
		resource.WithTelemetrySDK(),
		resource.WithHost(),
		resource.WithOS(),
		resource.WithSchemaURL(semconv.SchemaURL),
		resource.WithAttributes(
			semconv.ServiceName(o.config.ServiceName),
			semconv.ServiceVersion(o.config.Version),
			attribute.String("environment", o.environment.GetEnvironmentName()),
			semconv.TelemetrySDKVersionKey.String("v1.21.0"), // semconv version
			semconv.TelemetrySDKLanguageGo,
		))

	return resource, err
}

// initMetrics initializes the metrics.
func (o *OtelMetrics) initMetrics(
	resource *resource.Resource,
) (AppMetrics, error) {
	metricsExporter, err := o.configExporters()
	if err != nil {
		return nil, err
	}

	batchExporters := lo.Map(
		metricsExporter,
		func(item metric.Reader, _ int) metric.Option {
			return metric.WithReader(item)
		},
	)

	// https://opentelemetry.io/docs/instrumentation/go/exporting_data/#resources
	// Resources are a special type of attribute that apply to all spans generated by a process
	opts := append(
		batchExporters,
		metric.WithResource(resource),
	)

	// otel library collects metrics and send this metrics to some exporter like console or prometheus
	provider := metric.NewMeterProvider(opts...)

	// Register our MeterProvider as the global so any imported
	// instrumentation in the future will default to using it.
	otel.SetMeterProvider(provider)
	o.provider = provider

	appMeter := NewAppMeter(o.config.InstrumentationName)

	return appMeter, nil
}

// configExporters configures the exporters.
func (o *OtelMetrics) configExporters() ([]metric.Reader, error) {
	ctx := context.Background()
	metricOpts := []otlpmetricgrpc.Option{
		otlpmetricgrpc.WithTimeout(5 * time.Second),
		otlpmetricgrpc.WithInsecure(),
	}

	if o.config.UseOTLP {
		return o.configureOTLPExporters(ctx, metricOpts)
	}

	return o.configureLegacyExporters(ctx, metricOpts)
}

func (o *OtelMetrics) configureOTLPExporters(
	ctx context.Context,
	metricOpts []otlpmetricgrpc.Option,
) ([]metric.Reader, error) {
	var exporters []metric.Reader
	for _, oltpProvider := range o.config.OTLPProviders {
		if !oltpProvider.Enabled {
			continue
		}
		opts := append(metricOpts,
			otlpmetricgrpc.WithEndpoint(oltpProvider.OTLPEndpoint),
			otlpmetricgrpc.WithHeaders(oltpProvider.OTLPHeaders))

		exporter, err := otlpmetricgrpc.New(ctx, opts...)
		if err != nil {
			return nil, errors.WrapIf(err, "failed to create otlptracegrpc exporter")
		}
		metricExporter := metric.NewPeriodicReader(exporter, metric.WithInterval(3*time.Second))
		exporters = append(exporters, metricExporter)
	}

	return exporters, nil
}

func (o *OtelMetrics) configureLegacyExporters(
	ctx context.Context,
	metricOpts []otlpmetricgrpc.Option,
) ([]metric.Reader, error) {
	var exporters []metric.Reader

	if err := o.addStdoutExporter(&exporters); err != nil {
		return nil, err
	}
	if err := o.addElasticApmExporter(ctx, metricOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addUptraceExporter(ctx, metricOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addSignozExporter(ctx, metricOpts, &exporters); err != nil {
		return nil, err
	}
	if err := o.addPrometheusExporter(&exporters); err != nil {
		return nil, err
	}

	return exporters, nil
}

func (o *OtelMetrics) addStdoutExporter(exporters *[]metric.Reader) error {
	if !o.config.UseStdout {
		return nil
	}
	console, err := stdoutmetric.New()
	if err != nil {
		return errors.WrapIf(err, "error creating console exporter")
	}
	consoleMetricExporter := metric.NewPeriodicReader(console, metric.WithInterval(3*time.Second))
	*exporters = append(*exporters, consoleMetricExporter)

	return nil
}

func (o *OtelMetrics) addElasticApmExporter(
	ctx context.Context,
	metricOpts []otlpmetricgrpc.Option,
	exporters *[]metric.Reader,
) error {
	if o.config.ElasticApmExporterOptions == nil {
		return nil
	}
	opts := append(metricOpts,
		otlpmetricgrpc.WithEndpoint(o.config.ElasticApmExporterOptions.OTLPEndpoint),
		otlpmetricgrpc.WithHeaders(o.config.ElasticApmExporterOptions.OTLPHeaders))

	exporter, err := otlpmetricgrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create otlpmetric exporter for elastic-apm")
	}
	elasticApmExporter := metric.NewPeriodicReader(exporter, metric.WithInterval(3*time.Second))
	*exporters = append(*exporters, elasticApmExporter)

	return nil
}

func (o *OtelMetrics) addUptraceExporter(
	ctx context.Context,
	metricOpts []otlpmetricgrpc.Option,
	exporters *[]metric.Reader,
) error {
	if o.config.UptraceExporterOptions == nil {
		return nil
	}
	opts := append(metricOpts,
		otlpmetricgrpc.WithEndpoint(o.config.UptraceExporterOptions.OTLPEndpoint),
		otlpmetricgrpc.WithHeaders(o.config.UptraceExporterOptions.OTLPHeaders))

	exporter, err := otlpmetricgrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create otlpmetric exporter for uptrace")
	}
	uptraceExporter := metric.NewPeriodicReader(exporter, metric.WithInterval(3*time.Second))
	*exporters = append(*exporters, uptraceExporter)

	return nil
}

func (o *OtelMetrics) addSignozExporter(
	ctx context.Context,
	metricOpts []otlpmetricgrpc.Option,
	exporters *[]metric.Reader,
) error {
	if o.config.SignozExporterOptions == nil {
		return nil
	}
	opts := append(metricOpts,
		otlpmetricgrpc.WithEndpoint(o.config.SignozExporterOptions.OTLPEndpoint),
		otlpmetricgrpc.WithHeaders(o.config.SignozExporterOptions.OTLPHeaders))

	exporter, err := otlpmetricgrpc.New(ctx, opts...)
	if err != nil {
		return errors.WrapIf(err, "failed to create otlpmetric exporter for signoz")
	}

	signozExporter := metric.NewPeriodicReader(exporter, metric.WithInterval(3*time.Second))
	*exporters = append(*exporters, signozExporter)

	return nil
}

func (o *OtelMetrics) addPrometheusExporter(exporters *[]metric.Reader) error {
	if o.config.SignozExporterOptions != nil {
		return nil
	}
	prometheusExporter, err := prometheus.New()
	if err != nil {
		return errors.WrapIf(err, "error creating prometheus exporter")
	}
	*exporters = append(*exporters, prometheusExporter)

	return nil
}

// RegisterMetricsEndpoint registers the metrics endpoint.
// we could also use our existing server app port and a new /metrics endpoint instead of a new server with different port for our app metrics.
func (o *OtelMetrics) RegisterMetricsEndpoint(
	server contracts.EchoHTTPServer,
) {
	if o.config.UseOTLP {
		return
	}

	var metricsPath string
	if o.config.MetricsRoutePath == "" {
		metricsPath = "metrics"
	} else {
		metricsPath = o.config.MetricsRoutePath
	}

	// when we send request to /metrics endpoint, this handler gets singleton `prometheus.DefaultRegisterer` registry with calling `Collect` method on registered prometheus reader and get all get metrics and write them in /metrics endpoint output
	server.GetEchoInstance().
		GET(metricsPath, echo.WrapHandler(promhttp.Handler()))
}
